[
  {
    "objectID": "posts/code/advent-of-code-2015/index.html",
    "href": "posts/code/advent-of-code-2015/index.html",
    "title": "Advent of Code 2015",
    "section": "",
    "text": "A slow solution of Advent of Code 2015. The following is a write up of how to solve and the things I learned while doing so - look at the AOC reddit site for ninja level solutions.\nI am trying to\nFirst up, I’m importing all the libs I’ll use up here:\nCode\n# python essentials\nimport os\nimport re\nimport hashlib\nimport math\nfrom pathlib import Path\nfrom typing import List, NamedTuple\nfrom collections import defaultdict, namedtuple, Counter\n\n# useful external libs\n#import numpy as np\nimport pandas as pd\n\n# misc utils\nimport requests\n#from tqdm.notebook import trange, tqdm # progress bars for slow funcs\n#from functools import reduce \n\n# for plots, cause visuals\nimport matplotlib.pyplot as plt # goto python viz lib\n#import seaborn as sns # prettify matplotlib\nfrom IPython.display import display, Markdown\n\n# javascript plotting for interactive graphs\n#import altair as alt\n#import plotly.express as px\nSome helper functions to avoid rewriting the same code for all the problems:\nCode\ndef get_input(day:int=1, path=\"inputs\"):\n    try:\n        return (Path() / f\"{path}/{day}.txt\").read_text().strip()\n    except:\n        print(f\"Failed to load {day}.txt from `inputs` subdir.\")\n\ndef printmd(txt): display(Markdown(txt))"
  },
  {
    "objectID": "posts/code/advent-of-code-2015/index.html#day-1-not-quite-lisp",
    "href": "posts/code/advent-of-code-2015/index.html#day-1-not-quite-lisp",
    "title": "Advent of Code 2015",
    "section": "Day 1: Not Quite Lisp",
    "text": "Day 1: Not Quite Lisp\n# We’re standing at a inifinite building, and following instructions:( is up, ) is down to find the right floor.\nThis is simple - minus the ups from the downs:\n\n\nCode\nin1 = get_input(1)\nin1.count(\"(\") - in1.count(\")\")\n\n\n138\n\n\nA list comprehension version for kicks:\n\n\nCode\nsum([1 if char == \"(\" else -1 for char in in1])\n\n\n138\n\n\nfor part 2, we need to find the first time the we enter the basement while following the instructions.\n\n\nCode\nfloor, ans = 0, None\nfloors = []\n\nfor i, mv in enumerate(inp1):\n    if mv == \"(\":\n        floor += 1\n    else:\n        floor -= 1\n    \n    floors.append(floor)\n    \n    if floor == -1 and not ans:\n        ans = i + 1\n        printmd(f\"First reached the basement at timestep: **{i + 1}**\")\n        #break # no need to continue climbing\n\nplt.title(\"Floor Tracker\"); plt.xlabel(\"Timestep\"); plt.ylabel(\"Floor\")\nplt.axvline(x=ans, label=\"Part 2\", alpha=0.35)\nplt.axhline(y=-1, label=\"Basement\", color=\"red\", alpha=0.35)\nplt.axhline(y=138, label=\"Final Floor\", color=\"orange\", alpha=0.35)\nplt.plot(range(len(floors)), floors, label=\"Position\")\nplt.legend(loc=\"lower right\");\n\n\nFirst reached the basement at timestep: 1771"
  },
  {
    "objectID": "posts/code/advent-of-code-2015/index.html#day-2-i-was-told-there-would-be-no-math",
    "href": "posts/code/advent-of-code-2015/index.html#day-2-i-was-told-there-would-be-no-math",
    "title": "Advent of Code 2015",
    "section": "Day 2: I Was Told There Would Be No Math",
    "text": "Day 2: I Was Told There Would Be No Math\nHow much wrapping paper is needed to wrap a bunch of presents? We need 2*l*w + 2*w*h + 2*h*l paper, and the input is the l, w and h of each present.\nIn the bad old days of programming, this would be the perfect place to represent the data as a list or tuple in the form [3 ,3, 9] representing [l, w, h]. But now we can use namedtuples to make it easier to understand the data, and also it makes it easier to add more info, e.g type of paper used, cost etc:\n\n\nCode\nclass Present(NamedTuple):\n    l: int\n    w: int\n    h: int\n\ndata2 = [Present(*[int(x) for x in i.split(\"x\")]) for i in get_input(2).split(\"\\n\")]\ndata2[:4]\n\n\n[Present(l=29, w=13, h=26),\n Present(l=11, w=11, h=14),\n Present(l=27, w=2, h=5),\n Present(l=6, w=10, h=13)]\n\n\nNow to calcuate the area:\n\n\nCode\ndef get_present_area(p: Present) -&gt; int:\n    box_area = sum([2*p.l*p.w, 2*p.w*p.h, 2*p.h*p.l])\n    extra_paper = math.prod(sorted(p)[:2])\n    return box_area + extra_paper\n\nsum([get_present_area(x) for x in data2])\n\n\n1586300\n\n\nNow we need to calcuate the ribbon required, which is equal to the perimeter of the smallest face + cubic volume of the present\n\n\nCode\ndef ribbon(present: Present) -&gt; int:\n    \"\"\"takes in present, returns length of ribbon needed to wrap\"\"\"\n    l, w, h = sorted(present)\n    return 2*l + 2*w + l*w*h\n\nsum([ribbon(present) for present in data2])\n\n\n3737498"
  },
  {
    "objectID": "posts/code/advent-of-code-2015/index.html#day-3-perfectly-spherical-houses-in-a-vacuum",
    "href": "posts/code/advent-of-code-2015/index.html#day-3-perfectly-spherical-houses-in-a-vacuum",
    "title": "Advent of Code 2015",
    "section": "Day 3: Perfectly Spherical Houses in a Vacuum",
    "text": "Day 3: Perfectly Spherical Houses in a Vacuum\n# Santa is delivering presents to houses, and his movements is 1 step at a time: north (^), south (v), east (&gt;), or west (&lt;)\n\n\nCode\ninp3 = get_input(3)\n\ndirs = {\"^\": (0,1), \"&gt;\": (1,0), \"v\": (0,-1), \"&lt;\": (-1, 0)}\n\ndef get_moves(data):\n    moves = [(0,0)]  # starting point\n\n    for mv in data:\n        x, y = moves[-1] # x,y of current pos\n        xx, yy = dirs[mv]\n        moves.append((x + xx, y + yy))\n    return moves\n\nmoves = get_moves(inp3)\nc = Counter(moves)\nprintmd(f\"Santa visited **{len(c)}** unique places.\")\n\nx, y = zip(*moves)\n\nf, ax = plt.subplots(figsize=(10,6))\nplt.title(f\"Santa visited {len(c)} unique places in {len(moves)} visits\")\nax.plot(x,y, alpha=0.7, label=\"Santa's Movements\"); ax.legend();\n\n\nSanta visited 2565 unique places.\n\n\n\n\n\nfor part 2, we have two santas! They move alternatingly, so we can say Santa_1 does all the odd moves and Santa_2 does all the even moves:\n\n\nCode\nsanta_1 = get_moves(inp3[::2])  # all the odd moves\nsanta_2 = get_moves(inp3[1::2]) # all the even moves\n\ntwo_santas = Counter(santa_1 + santa_2)\nprintmd(f\"The two santas visited **{len(two_santas)}** unique places.\")\n\nf, ax = plt.subplots(figsize=(10,6))\nplt.title(f\"the two santas visited {len(two_santas)} unique places\")\n\nfor name, santa in zip((\"Bob\", \"Alice\"), (santa_1, santa_2)):\n    x, y = zip(*santa)\n    ax.plot(x,y, alpha=0.8, label=f\"Santa_{name}\")\nax.legend();\n\n\nThe two santas visited 2639 unique places."
  },
  {
    "objectID": "posts/code/advent-of-code-2015/index.html#day-4-the-ideal-stocking-stuffer",
    "href": "posts/code/advent-of-code-2015/index.html#day-4-the-ideal-stocking-stuffer",
    "title": "Advent of Code 2015",
    "section": "Day 4: The Ideal Stocking Stuffer",
    "text": "Day 4: The Ideal Stocking Stuffer\n#\n\n\nCode\ninp4 = \"bgvyzdsv\"\ntest4_1 = \"abcdef\" #609043\ntest4_2 = \"pqrstuv\" # 1048970\n\ndef make_hash(txt):\n    return hashlib.md5(txt.encode(\"utf\")).hexdigest()\n\n\n\nFalse\n\n\n\n\nCode\ndef day_4_1(inp=inp4, s=\"None\", target=\"00000\", i=0) -&gt; int:\n    while not s.startswith(target):\n        i += 1\n        txt = inp + str(i)\n        s = make_hash(txt)\n    printmd(f\"_{inp}_ target at position **{i:,}** ({s})\")\n    return i\n\nassert day_4_1(\"abcdef\") == 609043    # tests are always a good idea\nassert day_4_1(\"pqrstuv\") == 1048970    \n\nday_4_1()\n\n\nabcdef target at position 609,043 (000001dbbfa3a5c83a2d506429c7b00e)\n\n\npqrstuv target at position 1,048,970 (000006136ef2ff3b291c85725f17325c)\n\n\nbgvyzdsv target at position 254,575 (000004b30d481662b9cb0c105f6549b2)\n\n\n254575\n\n\nPart two just changes the target sring to have one more zero so thanks to making part one a function this is easy:\n\n\nCode\nday_4_1(target=\"000000\")\n\n\nbgvyzdsv target at position 1,038,736 (000000b1b64bf5eb55aad89986126953)\n\n\n1038736"
  },
  {
    "objectID": "posts/code/advent-of-code-2015/index.html#day-5-doesnt-he-have-intern-elves-for-this",
    "href": "posts/code/advent-of-code-2015/index.html#day-5-doesnt-he-have-intern-elves-for-this",
    "title": "Advent of Code 2015",
    "section": "Day 5: Doesn’t He Have Intern-Elves For This?",
    "text": "Day 5: Doesn’t He Have Intern-Elves For This?\n# We have a list of strings, and Santa has the following rules to figure out which ones are nice:\n\nat least three vowels (aeiou only), like aei, xazegov, or aeiouaeiouaeiou.\nat least one letter that appears twice in a row, like xx, abcdde (dd), or aabbccdd (aa, bb, cc, or dd).\ndoes not contain the strings ab, cd, pq, or xy, even if they are part of one of the other requirements.\n\n\n\nCode\nvowels = \"aeiou\"                        # need vowels\nbad_strings = [\"ab\", \"cd\", \"pq\", \"xy\"]  # don't want these\nregex = re.compile(r\"([a-zA-Z])\\1{1,}\") # search for 2+ letters in a row\n\ntest4 = [\"ugknbfddgicrmopn\", \"aaa\", \"jchzalrnumimnmhp\", \n        \"haegwjzuvuyypxyu\", \"dvszwmarrgswjxmb\"]\n\ndef is_nice_string(txt):\n    vowel_count = len([char for char in txt if char in vowels]) &gt;= 3\n    two_chars = len(re.findall(regex, txt)) &gt; 0\n    no_bad_str = True if (sum([s3d in txt for s in bad_strings]) == 0) else False\n    \n    return vowel_count and two_chars and no_bad_str\n\n[is_nice_string(t) for t in test4] #== [False, False, True, True, True]\n\n\n[True, True, False, False, False]\n\n\n\n\nCode\ninp5 = get_input(5).split(\"\\n\")\nprint(\"Number of nice strings: \", sum([is_nice_string(t) for t in inp5]))\n\n\nNumber of nice strings:  258\n\n\nfor part two, the rules have changed, a nice string has these properties:\n\nIt contains a pair of any two letters that appears at least twice in the string without overlapping, like xyxy (xy) or aabcdefgaa (aa), but not like aaa (aa, but it overlaps).\nIt contains at least one letter which repeats with exactly one letter between them, like xyx, abcdefeghi (efe), or even aaa.\n\n\nNote: the rest remains to be done\n\n\n\nCode\nregex_2char = re.compile(r\"([a-zA-Z])\\1{1,}\")\nregex_3char = re.compile(r\"([a-zA-Z])\\1{2,}\")\n\nfor txt in [\"aa\", \"aba\", \"aaa\"]:\n    print(re.findall(regex_2char, txt))\n\n\n['a']\n[]\n['a']"
  },
  {
    "objectID": "posts/code/advent-of-code-2015/index.html#day-6-probably-a-fire-hazard",
    "href": "posts/code/advent-of-code-2015/index.html#day-6-probably-a-fire-hazard",
    "title": "Advent of Code 2015",
    "section": "Day 6: Probably a Fire Hazard",
    "text": "Day 6: Probably a Fire Hazard\n#"
  },
  {
    "objectID": "posts/algorithims/flood_fill.html",
    "href": "posts/algorithims/flood_fill.html",
    "title": "Floodfill algorithim",
    "section": "",
    "text": "Flood Fill is a way to to visit every point in a bounded region. This makes it useful for many purposes. In this notebook I implement the “bucket fill” flood fill algo.\nFirst up generating a grid to flood fill:\nfill = np.random.randint(0, 2, size=(128,128), dtype=\"int\")\nfill\n\narray([[0, 1, 0, ..., 0, 1, 0],\n       [1, 1, 0, ..., 0, 0, 1],\n       [1, 1, 0, ..., 1, 0, 0],\n       ...,\n       [0, 1, 0, ..., 1, 1, 1],\n       [1, 1, 0, ..., 0, 1, 1],\n       [1, 0, 0, ..., 0, 1, 0]])\nEyeballing this grid visually:\nplt.imshow(fill);"
  },
  {
    "objectID": "posts/algorithims/flood_fill.html#the-floodfill-algo",
    "href": "posts/algorithims/flood_fill.html#the-floodfill-algo",
    "title": "Floodfill algorithim",
    "section": "the floodfill algo",
    "text": "the floodfill algo\nThe below function is a recursive implementation of flood fill - it will flood fill a a single region from 1 val to another:\n\ndef flood_fill(x, y, old, new):\n    \"\"\"takes in a x,y position from where to flood fill, the old val to change from and the new val\n    to change too, and then does so on a to_fill array\"\"\"\n    \n    if fill[x][y] != old or fill[x][y] == new:\n        return\n    \n    fill[x][y] = new\n    \n    max_x = len(fill) - 1\n    max_y = len(fill) - 1\n    \n    if x &gt; 0: # go left\n        flood_fill(x-1, y, old, new)\n    \n    if x &lt; max_x: # go right\n        flood_fill(x+1, y, old, new)\n        \n    if y &gt; 0: # go down\n        flood_fill(x, y-1, old, new)\n    if y &lt; max_y: # go up\n        flood_fill(x, y+1, old, new)\n\nHere, I flood fill the fill, converting all the 1’s to 8’s.\n\nregion_count = 0\n\nimagelist = list()\nimagelist.append(fill)\n\nfor i in range(len(fill)):\n    for j in range(len(fill[0])):\n        if fill[i][j] == 1:\n            flood_fill(i, j, 1, 8)\n            region_count += 1\n            imagelist.append(fill)\n            if region_count % 100 == 0:\n                plt.imshow(imagelist[region_count])\n                plt.title(f\"Flood Fill by region\")\n                plt.show()"
  },
  {
    "objectID": "posts/windows.html",
    "href": "posts/windows.html",
    "title": "Windows 10",
    "section": "",
    "text": "Windows 10 gets slow and crufty over time. So once every few years, its good to start afresh.\nReset by:\n\nStart -&gt; Settings -&gt; Update & Security -&gt; Recovery -&gt; Reset this PC\n\nOR, if windows is pretty borked, restart the surface and hold the shift key down. This should boot into a screen with a: Troubleshoot -&gt; Reset this PC.\n\n\n\ninstall scoop by running this in powershell:\niwr -useb get.scoop.sh | iex\nscoop bucket add extras\n\nRufus for making bootable disks. etcher is a decent alternative, but not as reliable.\n\n\n\n\nFollow the real wsl instructions, my clif notes are:\nRun powershell as admin and do:\nActivate wsl by dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\nEnable “virtual machine platform”, something which should have already been enabled by the command above.\nEnable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform -NoRestart\nRestart the pc now and set wsl2 as the default wsl: wsl --set-default-version 2\nNow install the latest linux kernel update package.\nNow install debian from the windows store."
  },
  {
    "objectID": "posts/windows.html#factory-reset",
    "href": "posts/windows.html#factory-reset",
    "title": "Windows 10",
    "section": "",
    "text": "Windows 10 gets slow and crufty over time. So once every few years, its good to start afresh.\nReset by:\n\nStart -&gt; Settings -&gt; Update & Security -&gt; Recovery -&gt; Reset this PC\n\nOR, if windows is pretty borked, restart the surface and hold the shift key down. This should boot into a screen with a: Troubleshoot -&gt; Reset this PC."
  },
  {
    "objectID": "posts/windows.html#setup",
    "href": "posts/windows.html#setup",
    "title": "Windows 10",
    "section": "",
    "text": "install scoop by running this in powershell:\niwr -useb get.scoop.sh | iex\nscoop bucket add extras\n\nRufus for making bootable disks. etcher is a decent alternative, but not as reliable."
  },
  {
    "objectID": "posts/windows.html#wsl-2",
    "href": "posts/windows.html#wsl-2",
    "title": "Windows 10",
    "section": "",
    "text": "Follow the real wsl instructions, my clif notes are:\nRun powershell as admin and do:\nActivate wsl by dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\nEnable “virtual machine platform”, something which should have already been enabled by the command above.\nEnable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform -NoRestart\nRestart the pc now and set wsl2 as the default wsl: wsl --set-default-version 2\nNow install the latest linux kernel update package.\nNow install debian from the windows store."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "KO",
    "section": "",
    "text": "The max area under a histogram\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nAug 8, 2023\n\n\nKO\n\n\n\n\n\n\n  \n\n\n\n\nQuarto Jupyter notebook test\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nAug 28, 2022\n\n\nKO\n\n\n\n\n\n\n  \n\n\n\n\nWindows 10\n\n\n\n\n\n\n\nwindows\n\n\n\n\n\n\n\n\n\n\n\nOct 28, 2020\n\n\nKO\n\n\n\n\n\n\n  \n\n\n\n\nAdvent of Code 2015\n\n\n\n\n\n\n\nalgorithims\n\n\npython\n\n\n\n\na verbose solve of AOC 2015\n\n\n\n\n\n\nAug 10, 2020\n\n\nKO\n\n\n\n\n\n\n  \n\n\n\n\nFloodfill algorithim\n\n\n\n\n\n\n\nalgorithims\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nAug 10, 2018\n\n\nKO\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Trying out Quarto as a code blog."
  },
  {
    "objectID": "about.html#a-future-about",
    "href": "about.html#a-future-about",
    "title": "About",
    "section": "",
    "text": "Trying out Quarto as a code blog."
  },
  {
    "objectID": "posts/algorithims/histogram_max_area.html",
    "href": "posts/algorithims/histogram_max_area.html",
    "title": "The max area under a histogram",
    "section": "",
    "text": "This is a popular coding interview question - which is really simple with a simple histogram using pen and paper, but harder to think about in code, as it takes a bit of thinking through.\nDetailed problem description: https://leetcode.com/problems/largest-rectangle-in-histogram/\nA few test arrays with the largest area:\n\ntests = (\n    ([2, 1, 5, 6, 2, 3], 10),\n    ([6, 3, 1, 4, 12, 4], 12),\n    ([5, 6, 7, 4, 1], 16),\n    ([2, 1, 3, 4, 1], 6),\n)\n\nWhich look like:\n\n\nCode\nfig, axes = plt.subplots(2, 2, layout=\"tight\")\nfor ax, (arr, ans) in zip(axes.flatten(), tests):\n    ax.set_axis_off()\n    bar = ax.bar(\n        range(len(arr)),\n        arr,\n        width=0.95,\n        alpha=0.8,\n        edgecolor=\"yellow\",\n    )\n    ax.set_title(f\"Largest rectange: {ans:2}\", loc=\"left\", fontsize=10)\n    ax.bar_label(bar, fontsize=8)\n\n\n\n\n\nLooking at the array makes it easy to see where the largest rectangle might be.\n\n\nWe can brute force this by generating the largest possible rectangle at every item in the array.\nI’m doing a simple alogrithm here:\nFor each N in the arry:\n\nfind the left and right boundary of the largest possible rectangle\nthis gives us the width, exluding the width of N itself (adding 1 to ad back N)\nso now we have the width, and the height is just the value N in the array\n\nTo keep things simple, first up a helper function which returns the rectangle boundaries of a given point in an array:\n\ndef find_boundary(idx: int, arr: list[int]) -&gt; tuple[int, int]:\n    \"\"\"\n    Example:\n        idx 2 for [2, 1, 5, 6, 2, 3] returns (2, 3)\n    Returns:\n        (left, right)\n    \"\"\"\n\n    # find left boundary (can be itself)\n    left = 0\n    if idx == left:\n        pass  # deals with the left edge\n    else:\n        # march leftwards all the way to zero:\n        for j in range(idx - 1, -1, -1):\n            if arr[j] &lt; arr[idx]:\n                left = j + 1  # adding 1 to exlude smaller item\n                break  # exit loop once the first boundary found\n\n    # find right boundary (can be itself)\n    right = len(arr) - 1  # deal with the right edge\n\n    if idx == right:\n        pass  # at right edge already\n    else:\n        # march rightwards\n        for j in range(idx, len(arr)):\n            if arr[j] &lt; arr[idx]:\n                right = j - 1  # subtracting 1 to exclude the smaller item\n                break\n\n    return left, right\n\n\n# testing this for the first arrary in the tests\nfor arr, ans in tests:\n    print(\"-----\", arr, \"---------\")\n    for i in range(len(arr)):\n        print(i, arr[i], find_boundary(i, arr))\n    break\n\n----- [2, 1, 5, 6, 2, 3] ---------\n0 2 (0, 0)\n1 1 (0, 5)\n2 5 (2, 3)\n3 6 (3, 3)\n4 2 (2, 5)\n5 3 (5, 5)\n\n\nThe find_boundary func is working, so now its easy to get the area of the max rectangle.\n\n\nThe below function iterates through every item in the array, calculates the area of the largest rectangle at that point, and updates the max area function.\n\ndef max_area(arr: list[int], viz: bool = False) -&gt; int:\n    \"\"\"returns the area of the biggest rectangle\"\"\"\n    max_area = 0\n    max_idx = None\n\n    for i in range(len(arr)):\n        left, right = find_boundary(i, arr)\n        # adding 1 to width as when we calc (right - left) it excludes itself\n        width = 1 + right - left\n\n        new_area = arr[i] * width\n        if new_area &gt; max_area:\n            max_area = new_area\n            max_idx = i\n\n    if viz:\n        return max_idx, max_area\n    else:\n        return max_area\n\n\nfor arr, ans in tests:\n    assert max_area(arr) == ans\n    print(f\"{arr} ----&gt; {max_area(arr)}\")\nprint(f\"all {len(tests)} tests passed!\")\n\n[2, 1, 5, 6, 2, 3] ----&gt; 10\n[6, 3, 1, 4, 12, 4] ----&gt; 12\n[5, 6, 7, 4, 1] ----&gt; 16\n[2, 1, 3, 4, 1] ----&gt; 6\nall 4 tests passed!\n\n\nThat was pretty straight forward, though a bit verbose. Now an excercise in plotting this visually:\n\n\n\nUsing matplotlib to plot te max rectangle at every position of the array…\nCopied the plot code above and added a func to highlight the largest rectange:\n\n# to use to show different rectangele with diff colors and fills\ncolors = list(mcolors.TABLEAU_COLORS.values())\nhatches = [\"/\", \"\\\\\", \"|\", \"-\", \"+\", \"x\", \"o\", \"O\", \".\", \"*\"]\n\n\n\nCode\nfig, axes = plt.subplots(2, 2, layout=\"tight\")\nfor ax, (arr, ans) in zip(axes.flatten(), tests):\n    ax.set_axis_off()\n    bar = ax.bar(\n        range(len(arr)),\n        arr,\n        width=0.95,\n        alpha=0.6,\n        edgecolor=\"yellow\",\n    )\n    ax.set_title(f\"Largest rectange: {ans:2}\", loc=\"left\", fontsize=10)\n    ax.bar_label(bar, fontsize=8)\n\n    idx, area = max_area(arr, True)\n\n    for i in range(len(arr)):\n        if i == idx:  # got too messy plotting all the rects\n            left, right = find_boundary(i, arr)\n            width = 1 + right - left\n            ax.add_patch(\n                Rectangle(\n                    (left - 0.5, 0),\n                    width,\n                    arr[i],\n                    alpha=0.35,\n                    facecolor=\"purple\",\n                    ls=\"--\",\n                    lw=2,\n                    hatch=hatches[5],\n                )\n            )\n\n\n\n\n\nEvery time I use matplotlib I’m both horrofied and inmpressed by what you can do it… basically anything but so much code…\n\n\n\n\nA work in progress…\nInstead of relooping through the array, we can use a stack to only go through the array once.\n\ndef histogram_max_area(arr):\n    stack = [-1]  # the stop or sentinel value\n    max_area = 0\n\n    for i in range(len(arr)):\n        while stack[-1] != -1 and arr[stack[-1]] &gt;= arr[i]:\n            current_height = arr[stack.pop()]\n            current_width = i - stack[-1] - 1\n            max_area = max(max_area, current_height * current_width)\n        stack.append(i)\n\n    while stack[-1] != -1:\n        current_height = arr[stack.pop()]\n        current_width = len(arr) - stack[-1] - 1\n        max_area = max(max_area, current_height * current_width)\n    return max_area\n\n\nfor arr, ans in tests:\n    assert histogram_max_area(arr) == ans\n    print(f\"{arr} ----&gt; {ans}\")\n\nprint(f\"all {len(tests)} tests passed!\")\n\n[2, 1, 5, 6, 2, 3] ----&gt; 10\n[6, 3, 1, 4, 12, 4] ----&gt; 12\n[5, 6, 7, 4, 1] ----&gt; 16\n[2, 1, 3, 4, 1] ----&gt; 6\nall 4 tests passed!"
  },
  {
    "objectID": "posts/algorithims/histogram_max_area.html#a-simple-solution",
    "href": "posts/algorithims/histogram_max_area.html#a-simple-solution",
    "title": "The max area under a histogram",
    "section": "",
    "text": "We can brute force this by generating the largest possible rectangle at every item in the array.\nI’m doing a simple alogrithm here:\nFor each N in the arry:\n\nfind the left and right boundary of the largest possible rectangle\nthis gives us the width, exluding the width of N itself (adding 1 to ad back N)\nso now we have the width, and the height is just the value N in the array\n\nTo keep things simple, first up a helper function which returns the rectangle boundaries of a given point in an array:\n\ndef find_boundary(idx: int, arr: list[int]) -&gt; tuple[int, int]:\n    \"\"\"\n    Example:\n        idx 2 for [2, 1, 5, 6, 2, 3] returns (2, 3)\n    Returns:\n        (left, right)\n    \"\"\"\n\n    # find left boundary (can be itself)\n    left = 0\n    if idx == left:\n        pass  # deals with the left edge\n    else:\n        # march leftwards all the way to zero:\n        for j in range(idx - 1, -1, -1):\n            if arr[j] &lt; arr[idx]:\n                left = j + 1  # adding 1 to exlude smaller item\n                break  # exit loop once the first boundary found\n\n    # find right boundary (can be itself)\n    right = len(arr) - 1  # deal with the right edge\n\n    if idx == right:\n        pass  # at right edge already\n    else:\n        # march rightwards\n        for j in range(idx, len(arr)):\n            if arr[j] &lt; arr[idx]:\n                right = j - 1  # subtracting 1 to exclude the smaller item\n                break\n\n    return left, right\n\n\n# testing this for the first arrary in the tests\nfor arr, ans in tests:\n    print(\"-----\", arr, \"---------\")\n    for i in range(len(arr)):\n        print(i, arr[i], find_boundary(i, arr))\n    break\n\n----- [2, 1, 5, 6, 2, 3] ---------\n0 2 (0, 0)\n1 1 (0, 5)\n2 5 (2, 3)\n3 6 (3, 3)\n4 2 (2, 5)\n5 3 (5, 5)\n\n\nThe find_boundary func is working, so now its easy to get the area of the max rectangle.\n\n\nThe below function iterates through every item in the array, calculates the area of the largest rectangle at that point, and updates the max area function.\n\ndef max_area(arr: list[int], viz: bool = False) -&gt; int:\n    \"\"\"returns the area of the biggest rectangle\"\"\"\n    max_area = 0\n    max_idx = None\n\n    for i in range(len(arr)):\n        left, right = find_boundary(i, arr)\n        # adding 1 to width as when we calc (right - left) it excludes itself\n        width = 1 + right - left\n\n        new_area = arr[i] * width\n        if new_area &gt; max_area:\n            max_area = new_area\n            max_idx = i\n\n    if viz:\n        return max_idx, max_area\n    else:\n        return max_area\n\n\nfor arr, ans in tests:\n    assert max_area(arr) == ans\n    print(f\"{arr} ----&gt; {max_area(arr)}\")\nprint(f\"all {len(tests)} tests passed!\")\n\n[2, 1, 5, 6, 2, 3] ----&gt; 10\n[6, 3, 1, 4, 12, 4] ----&gt; 12\n[5, 6, 7, 4, 1] ----&gt; 16\n[2, 1, 3, 4, 1] ----&gt; 6\nall 4 tests passed!\n\n\nThat was pretty straight forward, though a bit verbose. Now an excercise in plotting this visually:\n\n\n\nUsing matplotlib to plot te max rectangle at every position of the array…\nCopied the plot code above and added a func to highlight the largest rectange:\n\n# to use to show different rectangele with diff colors and fills\ncolors = list(mcolors.TABLEAU_COLORS.values())\nhatches = [\"/\", \"\\\\\", \"|\", \"-\", \"+\", \"x\", \"o\", \"O\", \".\", \"*\"]\n\n\n\nCode\nfig, axes = plt.subplots(2, 2, layout=\"tight\")\nfor ax, (arr, ans) in zip(axes.flatten(), tests):\n    ax.set_axis_off()\n    bar = ax.bar(\n        range(len(arr)),\n        arr,\n        width=0.95,\n        alpha=0.6,\n        edgecolor=\"yellow\",\n    )\n    ax.set_title(f\"Largest rectange: {ans:2}\", loc=\"left\", fontsize=10)\n    ax.bar_label(bar, fontsize=8)\n\n    idx, area = max_area(arr, True)\n\n    for i in range(len(arr)):\n        if i == idx:  # got too messy plotting all the rects\n            left, right = find_boundary(i, arr)\n            width = 1 + right - left\n            ax.add_patch(\n                Rectangle(\n                    (left - 0.5, 0),\n                    width,\n                    arr[i],\n                    alpha=0.35,\n                    facecolor=\"purple\",\n                    ls=\"--\",\n                    lw=2,\n                    hatch=hatches[5],\n                )\n            )\n\n\n\n\n\nEvery time I use matplotlib I’m both horrofied and inmpressed by what you can do it… basically anything but so much code…"
  },
  {
    "objectID": "posts/algorithims/histogram_max_area.html#using-stacks",
    "href": "posts/algorithims/histogram_max_area.html#using-stacks",
    "title": "The max area under a histogram",
    "section": "",
    "text": "A work in progress…\nInstead of relooping through the array, we can use a stack to only go through the array once.\n\ndef histogram_max_area(arr):\n    stack = [-1]  # the stop or sentinel value\n    max_area = 0\n\n    for i in range(len(arr)):\n        while stack[-1] != -1 and arr[stack[-1]] &gt;= arr[i]:\n            current_height = arr[stack.pop()]\n            current_width = i - stack[-1] - 1\n            max_area = max(max_area, current_height * current_width)\n        stack.append(i)\n\n    while stack[-1] != -1:\n        current_height = arr[stack.pop()]\n        current_width = len(arr) - stack[-1] - 1\n        max_area = max(max_area, current_height * current_width)\n    return max_area\n\n\nfor arr, ans in tests:\n    assert histogram_max_area(arr) == ans\n    print(f\"{arr} ----&gt; {ans}\")\n\nprint(f\"all {len(tests)} tests passed!\")\n\n[2, 1, 5, 6, 2, 3] ----&gt; 10\n[6, 3, 1, 4, 12, 4] ----&gt; 12\n[5, 6, 7, 4, 1] ----&gt; 16\n[2, 1, 3, 4, 1] ----&gt; 6\nall 4 tests passed!"
  },
  {
    "objectID": "posts/code/quarto_notebook_test.html",
    "href": "posts/code/quarto_notebook_test.html",
    "title": "Quarto Jupyter notebook test",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\nplt.show()\n\n\n\n\nFigure 1: A line plot test with caption"
  },
  {
    "objectID": "posts/code/quarto_notebook_test.html#polar-axis",
    "href": "posts/code/quarto_notebook_test.html#polar-axis",
    "title": "Quarto Jupyter notebook test",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\n\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\nplt.show()\n\n\n\n\nFigure 1: A line plot test with caption"
  },
  {
    "objectID": "posts/code/quarto_notebook_test.html#lets-try-some-seaborn",
    "href": "posts/code/quarto_notebook_test.html#lets-try-some-seaborn",
    "title": "Quarto Jupyter notebook test",
    "section": "Lets try some seaborn…",
    "text": "Lets try some seaborn…\n\nimport seaborn as sns\nsns.set_theme(style=\"ticks\", palette=\"pastel\")\n\n# Load the example tips dataset\ntips = sns.load_dataset(\"tips\")\n\n# Draw a nested boxplot to show bills by day and time\nsns.boxplot(x=\"day\", y=\"total_bill\",\n            hue=\"smoker\", palette=[\"m\", \"g\"],\n            data=tips)\nsns.despine(offset=10, trim=True)"
  },
  {
    "objectID": "posts/code/quarto_notebook_test.html#testing",
    "href": "posts/code/quarto_notebook_test.html#testing",
    "title": "Quarto Jupyter notebook test",
    "section": "testing…",
    "text": "testing…\nwhy isn’t quarto creating a _freeze directory? What stops it?"
  }
]